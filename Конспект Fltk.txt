Fltk



{=============================================FL::=======================================================================

Fl::run();
//Запускает цикл обработки событий FLTK. Этот метод обрабатывает события и управляет выполнением программы до момента завершения главного окна.

-----------------------------------------------------------------------------------------------------

Fl::wait() 
//функция в библиотеке FLTK, которая используется для ожидания возникновения событий и приостановки выполнения программы до тех пор,
//пока не произойдет какое-либо событие.

//Функция Fl::wait() блокирует выполнение программы, ожидая, пока не произойдет какое-либо событие в приложении, такое как нажатие клавиши
//или клик мыши. Как только происходит событие, функция завершает свое выполнение и возвращает управление.

-----------------------------------------------------------------------------------------------------
Fl::scheme("plastic");
//Fl::scheme позволяет выбрать различные схемы оформления для придания интерфейсу различных стилей. Другие варианты схем оформления,
//которые могут быть использованы, включают:

"plastic" - стиль, напоминающий пластиковые элементы интерфейса.

"gleam" - стиль, придающий элементам блеск.

"none" - отключает использование схемы оформления, оставляя виджеты с их стандартным внешним видом.

"gtk+" - стиль, похожий на схему оформления GTK+.
------------------------------------------------------------------------------------------------------

Fl::version();
const char* version = Fl::version();
//Возвращает текущую версию FLTK в виде строки.

-----------------------------------------------------------------------------------------------------

Fl::check();
//Проверяет соответствие версии FLTK, с которой была скомпилирована программа, версии, используемой во время выполнения.
if (Fl::check() == FLTK_VERSION) {
    // Версии совпадают
}

-----------------------------------------------------------------------------------------------------

Fl::lock() и Fl::unlock()
//Обеспечивают мьютекс для безопасного доступа к ресурсам FLTK из нескольких потоков.
//В контексте многозадачности и параллельного программирования мьютекс (mutex) - это средство синхронизации доступа к общему ресурсу,
//такому как переменная или набор переменных. Мьютекс обеспечивает эксклюзивный доступ к ресурсу, что означает, что только один поток 
//может владеть мьютексом в любой момент времени.

//Fl::lock() и Fl::unlock() в FLTK предоставляют мьютекс для безопасного доступа к ресурсам библиотеки из нескольких потоков. 
//Эти методы используются для управления доступом к внутренним структурам данных FLTK, чтобы избежать проблем с параллельным доступом.

void my_thread_function() {
    // ... код потока ...

    // Захватываем мьютекс перед доступом к ресурсам FLTK
    Fl::lock();

    // ... код, выполняющийся в критической секции ...

    // Освобождаем мьютекс после использования ресурсов FLTK
    Fl::unlock();

    // ... остальной код потока ...
}
// Запускаем поток с функцией, в которой используется мьютекс
std::thread thread(my_thread_function);
// Ожидаем завершения дочернего потока
thread.join();


-----------------------------------------------------------------------------------------------------

Fl::screen_scale()

//screen_scale() возвращает коэффициент масштабирования экрана, который отражает текущий масштаб отображения.
//Этот коэффициент используется для коррекции размеров и положения элементов интерфейса в соответствии с текущим масштабом экрана.

double scale = Fl::screen_scale();
//Значение scale будет равно 1.0, если масштабирование не включено или установлено в единичное значение (100%).
//Если масштабирование включено (например, на устройствах с высоким DPI), scale будет отличным от 1.0, показывая текущий коэффициент масштабирования.
//Возвращает коэффициент масштабирования экрана.

-----------------------------------------------------------------------------------------------------

Fl::get_system_colors();

//Получает системные цвета и устанавливает их в буфер цветов FLTK.
}=======================================================================================================================
{=============================================int handle(int event)======================================================

//Метод handle(int event) является важным методом в библиотеке FLTK, и он используется для обработки событий,
//происходящих с виджетом, к которому он привязан. Когда происходит событие, вызывается метод handle, и вам 
//предоставляется возможность обработать это событие в соответствии с вашими потребностями.

//Возвращаемое значение int представляет собой флаг, который сообщает FLTK, как оно должно обрабатывать событие:

//Если возвращаемое значение равно 1, FLTK обрабатывает событие.
//Если возвращаемое значение равно 0, FLTK передает событие родителю (если есть).
//Если возвращаемое значение равно -1, FLTK игнорирует событие.

//~~~~~Пример реализации метода handle для Fl_Slider:

	class MySlider : public Fl_Slider {
	public:
		MySlider(int x, int y, int w, int h, const char* label = 0) : Fl_Slider(x, y, w, h, label) {}

		int handle(int event) override {
			switch (event) {
				case FL_PUSH:
					std::cout << "Mouse button pressed on the slider!" << std::endl;
					return 1; // Обработали событие
				case FL_RELEASE:
					std::cout << "Mouse button released on the slider!" << std::endl;
					return 1; // Обработали событие
				default:
					// Другие события не обрабатываем
					return Fl_Slider::handle(event);
			}
		}
	};

//В этом примере мы создаем подкласс MySlider, унаследованный от Fl_Slider, и переопределяем метод handle.
//Мы обрабатываем события FL_PUSH (нажатие кнопки мыши) и FL_RELEASE (отпускание кнопки мыши) и выводим сообщения в консоль.
//Остальные события передаются родителю для стандартной обработки.

//~~~~~Пример реализации метода handle для Fl_Input:

	class MyWindow : public Fl_Window {
	public:
		MyWindow(int w, int h, const char* title) : Fl_Window(w, h, title) {}

		int handle(int event) override {
			switch (event) {
				case FL_FOCUS:
					std::cout << "Window got focus!" << std::endl;
					return 1;
				default:
					return Fl_Window::handle(event);
			}
		}
	};
}=======================================================================================================================
{=============================================when()=====================================================================

//В библиотеке FLTK флаги when() используются для указания типов событий, на которые виджет должен реагировать.
//Вот некоторые из основных флагов, которые можно использовать в when():
//Пример:


button->when(FL_WHEN_CHANGED | FL_WHEN_RELEASE);  // Реагировать на изменение значения и отпускание кнопки мыши
input->when(FL_WHEN_CHANGED);                     // Реагировать на изменение значения
slider->when(FL_WHEN_CHANGED | FL_WHEN_RELEASE);  // Реагировать на изменение значения и отпускание кнопки мыши
checkButton->when(FL_WHEN_CHANGED);               // Реагировать на изменение значения
radioButton->when(FL_WHEN_CHANGED);				  // Реагировать на изменение значения

FL_WHEN_NEVER:
Означает, что виджет не будет реагировать на события.

FL_WHEN_CHANGED:
Позволяет виджету реагировать на изменения значения (например, при изменении текста в Fl_Input).

FL_WHEN_RELEASE:
Позволяет виджету реагировать, когда кнопка мыши отпускается после щелчка.

FL_WHEN_ENTER_KEY:
Реагировать на событие, когда пользователь нажимает клавишу Enter.

FL_WHEN_NOT_CHANGED:
Реагировать, когда значение виджета не изменено.

FL_WHEN_NOT_CHANGED_NONWORKING:
Похож на FL_WHEN_NOT_CHANGED, но не срабатывает, если виджет неактивен.

FL_WHEN_RELEASE_ALWAYS:
Срабатывать всегда при отпускании кнопки мыши.

FL_WHEN_ENTER_KEY_ALWAYS:
Срабатывать всегда при нажатии клавиши Enter.

FL_WHEN_RELEASE_ALWAYS:
Срабатывать всегда при отпускании кнопки мыши.

FL_WHEN_ENTER_KEY_ALWAYS:
Срабатывать всегда при нажатии клавиши Enter.

FL_WHEN_NOT_CHANGED_NONWORKING:
Похож на FL_WHEN_NOT_CHANGED, но не срабатывает, если виджет неактивен.

FL_WHEN_NEVER:
Означает, что виджет не будет реагировать на события.

FL_WHEN_CHANGED:
Позволяет виджету реагировать на изменения значения (например, при изменении текста в Fl_Input).

FL_WHEN_RELEASE:
Позволяет виджету реагировать, когда кнопка мыши отпускается после щелчка.

FL_WHEN_ENTER_KEY:
Реагировать на событие, когда пользователь нажимает клавишу Enter.

FL_WHEN_NOT_CHANGED:
Реагировать, когда значение виджета не изменено.

FL_WHEN_NOT_CHANGED_NONWORKING:
Похож на FL_WHEN_NOT_CHANGED, но не срабатывает, если виджет неактивен.

FL_WHEN_RELEASE_ALWAYS:
Срабатывать всегда при отпускании кнопки мыши.

FL_WHEN_ENTER_KEY_ALWAYS:
Срабатывать всегда при нажатии клавиши Enter.

FL_WHEN_NOT_CHANGED_NONWORKING:
Похож на FL_WHEN_NOT_CHANGED, но не срабатывает, если виджет неактивен.

FL_WHEN_NEVER:
Означает, что виджет не будет реагировать на события.

FL_WHEN_CHANGED:
Позволяет виджету реагировать на изменения значения (например, при изменении текста в Fl_Input).

FL_WHEN_RELEASE:
Позволяет виджету реагировать, когда кнопка мыши отпускается после щелчка.

FL_WHEN_ENTER_KEY:
Реагировать на событие, когда пользователь нажимает клавишу Enter.

FL_WHEN_NOT_CHANGED:
Реагировать, когда значение виджета не изменено.

FL_WHEN_NOT_CHANGED_NONWORKING:
Похож на FL_WHEN_NOT_CHANGED, но не срабатывает, если виджет неактивен.

FL_WHEN_RELEASE_ALWAYS:
Срабатывать всегда при отпускании кнопки мыши.

FL_WHEN_ENTER_KEY_ALWAYS:
Срабатывать всегда при нажатии клавиши Enter.

FL_WHEN_NOT_CHANGED_NONWORKING:
Похож на FL_WHEN_NOT_CHANGED, но не срабатывает, если виджет неактивен.
}======================================================================================================================
{=============================================callback(Fl_Widget* widget, void* data)====================================

//Колбэк представляет собой функцию, которая будет вызываться, когда происходит определенное событие для данного виджета.
//Например, когда пользователь нажимает кнопку мыши на кнопке (Fl_Button), вызывается соответствующая функция колбэка.

Fl_Widget widget:*

//Этот указатель указывает на виджет, который инициировал событие. Вы можете использовать его, чтобы получить информацию
//о виджете и его состоянии. Например, если ваш колбэк связан с кнопкой (Fl_Button), то widget будет указывать на эту кнопку.

void data:*

//Этот указатель предоставляет вам возможность передавать пользовательские данные в ваш колбэк. Когда устанавливаете колбэк,
//вы можете передать указатель на какую-то структуру или данные, которые могут быть полезны в контексте обработки события.
//data - это указатель на неопределенный тип данных (void*), нужно  явно привести его к нужному типу.

примеры:
----------------------------------------button-----------------------------------------------------------------------

button->callback(ButtonCallback, nullptr);

void ButtonCallback(Fl_Widget* widget, void* data) {
    // Обработка события кнопки
    Fl_Button* button = dynamic_cast<Fl_Button*>(widget);
    if (button) {
        // Доступ к свойствам кнопки и обработка события
        // ...
    }
}

----------------------------------------input------------------------------------------------------------------------

input->callback(InputCallback, nullptr);

void InputCallback(Fl_Widget* widget, void* data) {
    // Обработка события ввода
    Fl_Input* input = dynamic_cast<Fl_Input*>(widget);
    if (input) {
        // Доступ к введенным данным и обработка события
        // ...
    }
}
-----------------------------------------Slider----------------------------------------------------------------------

slider->callback(SliderCallback, nullptr);

void SliderCallback(Fl_Widget* widget, void* data) {
    // Обработка события слайдера
    Fl_Slider* slider = dynamic_cast<Fl_Slider*>(widget);
    if (slider) {
        // Доступ к значению слайдера и обработка события
        // ...
    }
}
}=======================================================================================================================
{=============================================Widgets====================================================================

{------------------------------------------Fl_Window:----------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Window.H>
#include <FL/Fl_Gl_Window.H>
#include <FL/Fl_Single_Window.H>
#include <FL/Fl_Group.H>
#include <FL/Fl_Window_Form.H>

//Fl_Window в библиотеке FLTK представляет собой базовый виджет для создания оконных приложений.
//Он предоставляет интерфейс для создания основного окна, в котором могут содержаться другие виджеты.

	Fl_Window* win = new Fl_Window(250, 220, "Simple Browser");         	       // базовый тип окна в FLTK.

	Fl_Gl_Window* glWin = new Fl_Gl_Window(250, 220, "OpenGL Browser");            // тип окна предназначен для работы с OpenGL.

	Fl_Single_Window* singleWin = new Fl_Single_Window(250, 220, "Single Browser");// тип окна предоставляет простое однопанельное окно.

	Fl_Group* group = new Fl_Group(10, 10, 250, 220, "Grouped Browser");           // Fl_Group - это контейнер для группировки виджетов. 

	Fl_Window_Form* formWin = new Fl_Window_Form(250, 220, "Form Browser");        // Этот тип окна предоставляет возможность управления
	
//Fl_Window_Form:(не стандартный виджет, может потребоваться установка отдельно)   // расположением виджетов с использованием форм.

//~~~~~Методы:

	Fl_Window(int w, int h, const char* label = 0): //Конструктор, создающий окно с указанными шириной (w), высотой (h) и заголовком (label).

	void callback(Fl_Callback* cb, void* data);     //Устанавливает колбэк для окна.
	callback(Fl_Callback* cb, void* data)           // это метод, позволяющий установить глобальный колбэк для всех событий, происходящих с окном.
												    // Этот колбэк будет вызываться при любом событии для данного окна, таким образом, он не привязан к конкретному виджету.
void WindowCallback(Fl_Widget* widget, void* data) {
    // Обработка событий окна
    Fl_Window* window = dynamic_cast<Fl_Window*>(widget);
    if (window) {
        printf("Window event occurred!\n");
    }
}
void begin();                       //Начинает блок, в пределах которого вы можете создавать и добавлять дочерние виджеты. 
void end();      					//Завершает описание содержимого окна. После вызова этого метода больше нельзя добавлять новые виджеты в окно.
void show();						//Показывает окно на экране.
void hide();						//Скрывает окно.

void resizable(Fl_Widget* widget);  //Устанавливает виджет, относительно которого будет изменяться размер окна.
win->resizable(win->w(), win->h()); //Устанавливает изменяемость по обеим осям (ширине и высоте). Таким образом, окно будет изменяемо в обе стороны.
win->resizable(win->w(), 0);		//Устанавливает изменяемость только по ширине. Высота окна будет фиксированной.
win->resizable();					//Устанавливает изменяемость по обеим осям. Это эквивалентно первой строке кода.
win->resizable(0);					//Блокирует изменения размеров окна, делая его неизменяемым.

Fl_Widget* resizable();				//Возвращает виджет, относительно которого изменяется размер окна.

void position(int x, int y);		//Устанавливает позицию окна на экране по координатам (x, y).
void size(int w, int h);			//Устанавливает размер окна.
void hotspot(int x, int y);			//Устанавливает горячую точку (точку, относительно которой будут происходить изменения размера окна).

void show(int argc, char** argv);   //Показывает окно с передачей аргументов командной строки.

void fullscreen();					//Разворачивает окно на весь экран.
void iconize():						//Сворачивает окно в иконку.

void make_current();				//Делает окно текущим для графического контекста.
void set_modal();					//Устанавливает окно в модальное состояние (остальные окна становятся недоступными до закрытия модального окна).
void clear_modal();					//Отменяет модальный режим окна.

void set_cursor(int cursor);        //Устанавливает курсор мыши для окна.

void iconlabel(const char* label)	//Устанавливает метку для иконки.
void copy_label(const char* label)	//Копирует метку окна.

void icon(Fl_RGB_Image* icon);      //Устанавливает иконку для окна.

Fl_RGB_Image* icon = new Fl_RGB_Image(nullptr, 16, 16, 3);  // Параметры: данные изображения, ширина, высота, количество каналов
// Здесь вы можете загрузить данные из файла или другого источника в изображение.
// Пример загрузки из файла:
// Fl_RGB_Image* icon = Fl_RGB_Image::get("path/to/your/icon.png");
window->icon(icon);

}
{------------------------------------------Fl_Button:----------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Button.H>
#include <FL/Fl_Check_Button.H>
#include <FL/Fl_Radio_Button.H>
#include <FL/Fl_Toggle_Button.H>

//Класс Fl_Button предоставляет несколько методов для работы с кнопками в библиотеке FLTK.
// 10, 10 - координаты верхнего левого угла виджета.
// 100, 30 - ширина и высота виджета.
// "Click Me" - текст кнопки

	Fl_Button* button = new Fl_Button(10, 10, 100, 30, "Click Me");
	Fl_Check_Button* checkButton = new Fl_Check_Button(10, 50, 120, 30, "Check Me");
	Fl_Radio_Button* radioButton = new Fl_Radio_Button(10, 90, 140, 30, "Radio Button");
	Fl_Toggle_Button* toggleButton = new Fl_Toggle_Button(10, 130, 160, 30, "Toggle Me");

	button->callback(ButtonCallback); // установка коллбэка
	
	void ButtonCallback(Fl_Widget* widget, void* data) {
		// Обработка события кнопки
		// ...
	}

//~~~~~Дополнительные методы:

button->label("New Text");               // Установка нового текста для кнопки
const char* labelText = button->label(); // Получение текущего текста кнопки
button->activate();  					 // Сделать кнопку активной
button->deactivate();					 // Сделать кнопку неактивной
button->set();   						 // Установить флаг переключателя (включить)
button->clear(); 					     // Снять флаг переключателя (выключить)
int isToggled = button->value();         // Возвращает 1, если флаг установлен, 0 в противном случае
button->take_focus(); 					 // Установка/снятие флага фокуса (для клавиатурной навигации): Разрешить кнопке принимать фокус
button->clear_visible_focus();
void* data = button->user_data();   	 // Получение пользовательских данных
button->user_data(newData);         	 // Установка новых пользовательских данных
button->shortcut(FL_CTRL + 'A');         // Обработка клавиш (горячие клавиши): Установка горячей клавиши (Ctrl+A)

//~~~~~Установка стилей отображения:

button->down_box(FL_NO_BOX);// Установить стиль визуализации кнопки (FL_NO_BOX, FL_FLAT_BOX, FL_UP_BOX и другие)

	//Без обводки                      :  FL_NO_BOX		
	//Плоская обводка                  :  FL_FLAT_BOX      Обводка с закругленными углами 		   : FL_BORDER_BOX
	//Выпуклая обводка                 :  FL_UP_BOX		   Выпуклая обводка с закругленными углами : FL_SHADOW_BOX
	//Выпуклая темная обводка		   :  FL_UP_FRAME_BOX  Выпуклая обводка с темным фоном 		   : FL_ENGRAVED_BOX
	//Выпуклая обводка с светлым фоном :  FL_EMBOSSED_BOX  Cвой собственный стиль                  : MyCustomBoxType;

	//Где MyCustomBoxType - это пользовательский стиль,
	//который можно определить и использовать.
	//Пользовательский стиль обычно представляется числовым
	//значением, которое вы определяете самостоятельно.

button->color(FL_BLUE);      			 // Установка цвета кнопки
button->labelcolor(FL_WHITE);			 // Установка цвета текста кнопки
button->labelsize(16); 			         // Установка размера шрифта текста кнопки
}
{------------------------------------------Fl_Input:-----------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Input.H>

Fl_Input* input = new Fl_Input(10, 170, 180, 30, "Input Field");

// Класс Fl_Input в библиотеке FLTK представляет собой виджет для ввода текста. 
// 10, 170 - координаты верхнего левого угла виджета.
// 180, 30 - ширина и высота виджета.
// "Input Field" - метка, отображаемая рядом с полем ввода.

//~~~~~Установка и получение текста:

	input->value("Default Text");      // Установка текста по умолчанию
	const char* text = input->value(); // Получение текущего текста

//~~~~~Установка ограничений на ввод:

	input->maximum_size(50);           // Максимальная длина текста
	input->input_type(FL_FLOAT_INPUT); // Разрешение только ввода чисел

//~~~~~Обработка событий:

	input->when(FL_WHEN_CHANGED);             // Обработка изменений в тексте по мере ввода
	//Когда установлен данный режим, функция обратного вызова (если она установлена)
	//будет вызываться немедленно после каждого изменения текста внутри Fl_Input.
	//Это полезно, например, когда вам нужно реагировать на изменения в реальном времени,
	//например, для поиска или фильтрации данных по мере ввода пользователя.

	input->callback(InputCallback, userData); // Установка функции обратного вызова

	//Пример:
	input->callback(InputCallback, nullptr);

	void InputCallback(Fl_Widget* widget, void* userData) {
		const char* text = static_cast<Fl_Input*>(widget)->value();
		printf("Input changed: %s\n", text);
		
		
	}

//~~~~~Установка стилей отображения:

	input->align(FL_ALIGN_LEFT);  	    // Выравнивание текста (FL_ALIGN_LEFT, FL_ALIGN_RIGHT, FL_ALIGN_CENTER)
	input->textsize(14); 			    // Размер шрифта текста
	input->color(FL_WHITE); 			// Установка цвета текста
	input->textcolor(FL_RED); 			// Установка цвета текста
	input->textbgcolor(FL_BLUE);        // Установка цвета фона текста
	input->input_type(FL_SECRET_INPUT); // Скрытие вводимого текста (поле для ввода пароля)
	//Подсказка (Placeholder):
	//Вставка текста-подсказки, который будет отображаться в поле до тех пор, пока пользователь не начнет вводить текст.
	input->when(FL_WHEN_ENTER_KEY);         // Ожидание нажатия клавиши Enter для отображения подсказки
	input->tooltip("Enter your text here"); // Установка текста подсказки
	
//~~~~~Дополнительные методы:

	input->value(""); 		// Очистка текста
	input->hide(); 			// Скрыть виджет
	input->show(); 			// Показать виджет
	input->deactivate(); 	// Заблокировать виджет
	input->activate(); 		// Разблокировать виджет
}
{------------------------------------------Fl_Output:----------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Output.H>

//Fl_Output - это виджет библиотеки FLTK, предназначенный для отображения текстовой информации.
//Fl_Output предоставляет простой способ вывода статического текста или значений переменных на графическом интерфейсе.

Fl_Output* output = new Fl_Output(10, 210, 200, 30, "Output Field");

//Fl_Output также поддерживает обработку событий с использованием callback-функции.
//Функция OutputCallback будет вызываться при изменении значения в Fl_Output.

output->callback(OutputCallback, userData);

//~~~~~Дополнительные методы:

output->value("Output Value"); 		  // установка значения
const char* text = output->value();   // hолучение значения
output->color(FL_WHITE);       	      // Установка цвета фона
output->textcolor(FL_BLACK);          // Установка цвета текста
output->align(FL_ALIGN_LEFT);         // Выравнивание текста по левому краю
output->textvalign(FL_ALIGN_MIDDLE);  // Установка выравнивания текста по середине. По умолчанию текст выравнивается по верхнему краю.
output->textsize(14); 			      // Установка размера шрифта текста
output->maximum_size(100); 	          // Установка максимальной длины текста (количество символов)
int maxSize = output->maximum_size(); // Получение максимальной длины
//Установка/получение максимального количества отображаемых символов:
output->position(10, 20); 			             // Установка позиции отображаемого текста (отступ слева и сверху)
int positionX, positionY;
output->position(positionX, positionY);          // Получение текущей позиции
output->when(FL_WHEN_CHANGED | FL_WHEN_RELEASE); // Отключение автопрокрутки

}
{------------------------------------------Fl_Slider:----------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Slider.H>

Fl_Slider* slider = new Fl_Slider(10, 250, 220, 30, "Slider");

//Fl_Slider в библиотеке FLTK представляет собой виджет ползунка (слайдера),
//который можно использовать для выбора значения в указанном диапазоне.

double value(double)    //Устанавливает или получает текущее значение слайдера. Значение должно быть в пределах, определенных minimum и maximum
void minimum(double)    //Устанавливает или получает минимальное значение для слайдера.
void maximum(double)    //Устанавливает или получает максимальное значение для слайдера.
void step(double)       //Устанавливает или получает шаг изменения значения при движении слайдера.
void bounds(double a, double b) //Устанавливает минимальное и максимальное значения слайдера.
void type(int)          //Устанавливает тип слайдера (горизонтальный или вертикальный). Используйте константы FL_HORIZONTAL или FL_VERTICAL
void slider_size(double)//Устанавливает или получает размер ползунка слайдера.
double slider() const	//Возвращает размер ползунка слайдера
void voidset_flag(int flag)    //Устанавливает определенный флаг слайдера set_flag(FL_ALIGN_LEFT)
int get_flag(int flag) const   //Проверяет, установлен ли определенный флаг слайдера.
void precision(int decimals)   //Устанавливает количество знаков после запятой для отображения значения слайдера.
void textsize(int s)    //Устанавливает размер шрифта для текстовой метки слайдера

}
{------------------------------------------Fl_Scrollbar:-------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Scrollbar.H>

//Класс Fl_Scrollbar в библиотеке FLTK представляет собой полосу прокрутки. Вот несколько методов этого класса:

Fl_Scrollbar* scrollbar = new Fl_Scrollbar(10, 290, 240, 30, "Scrollbar");

double value() const        		   //Возвращает текущее значение полосы прокрутки.
double slider_size() const 			   //Возвращает текущий размер бегунка на полосе прокрутки.
void bounds(double& a, double& b) const//Возвращает текущие границы значений полосы прокрутки через параметры a и b.
double step() const					   //Возвращает текущий размер шага прокрутки.
int type() const					   //Возвращает текущий тип полосы прокрутки (горизонтальная или вертикальная).
}
{------------------------------------------Fl_Menu_Bar:--------------------------------------------
#include <FL/Fl.H>
#include <FL/Fl_Menu_Bar.H>

//Fl_Menu_Bar - это виджет библиотеки FLTK, предназначенный для создания горизонтального бара меню.
Fl_Menu_Bar* menuBar = new Fl_Menu_Bar(0, 0, 300, 30, "Menu Bar");

void add(Fl_Menu_Item* items)  		//Добавляет массив элементов меню.
void remove(int index)			    //Удаляет элемент меню по индексу.
void clear()						//Удаляет все элементы меню.
void menu(const Fl_Menu_Item* menu) //Устанавливает меню элемента.
const Fl_Menu_Item* menu() const    //Возвращает индекс выбранного элемента меню.
int value() const					//Возвращает индекс выбранного элемента меню.
void value(int)						//Устанавливает индекс выбранного элемента меню.

{//Fl_Menu_Item представляет элемент меню в библиотеке FLTK. Этот класс используется для определения структуры меню, включая подменю и команды.

	#include <FL/Fl_Menu_Item.H>
	
	Fl_Menu_Item(const char* label, int shortcut, Fl_Callback* cb = 0, void* data = 0, int flags = 0, int user_data = 0);
		//label:     Текстовая метка элемента меню.
		//shortcut:  Горячая клавиша (FL_CTRL + 'A', например).
		//cb:        Функция обратного вызова, вызываемая при выборе элемента меню.
		//data:      Дополнительные данные, передаваемые в функцию обратного вызова.
		//flags:     Дополнительные флаги (например, FL_MENU_TOGGLE для переключаемых элементов).
		//user_data: Дополнительные пользовательские данные.
		
	static Fl_Menu_Item* end()     //Возвращает указатель, обозначающий конец массива. Используется для определения конца списка элементов меню.
	static Fl_Menu_Item* more()    //Возвращает указатель, обозначающий, что следующий элемент меню следует рассматривать как часть текущего элемента.
								   //Используется для создания подменю.
	int is_end() const			   //Проверяет, является ли данный элемент меню концом списка.	
	static Fl_Menu_Item separator()//Создает разделитель (линию) в меню.
	//Доступ к атрибутам:
		label()     //Возвращает текстовую метку элемента меню.
		shortcut()	//Возвращает горячую клавишу элемента меню.
		callback()  //Возвращает функцию обратного вызова элемента меню.
		flags()		//Возвращает флаги элемента меню.
		user_data() //Возвращает пользовательские данные элемента меню.
}

//~~~~~Пример :



void menu_callback(Fl_Widget* widget, void* data) {
    Fl_Menu_Item* item = (Fl_Menu_Item*)widget;
    // Обработка выбора элемента меню
    printf("Selected: %s\n", item->label());
}

int main() {
    // Создаем главное окно
    Fl_Window* window = new Fl_Window(300, 200, "Simple Menu");

    // Создаем панель меню
    Fl_Menu_Bar* menuBar = new Fl_Menu_Bar(0, 0, 300, 30);
    Fl_Menu_Item menuItems[] = {
        {"File", 0, 0, 0, FL_SUBMENU},
        {"Open", FL_CTRL + 'O', menu_callback},
        {"Save", FL_CTRL + 'S', menu_callback},
        {"Exit", FL_CTRL + 'Q', menu_callback},
        {0},
        {"Edit", 0, 0, 0, FL_SUBMENU},
        {"Cut", FL_CTRL + 'X', menu_callback},
        {"Copy", FL_CTRL + 'C', menu_callback},
        {"Paste", FL_CTRL + 'V', menu_callback},
        {0},
        {0}
    };

    menuBar->copy(menuItems);

    // Завершаем создание главного окна
    window->end();
    window->show();

    // Запускаем главный цикл обработки событий
    return Fl::run();
}

}
{------------------------------------------Fl_Choice:----------------------------------------------

#include <FL/Fl.H>
#include <FL/Fl_Choice.H>
//Fl_Choice - это виджет выпадающего списка в библиотеке FLTK. Этот виджет позволяет пользователю выбирать
//один из нескольких вариантов из предоставленного списка. Вот некоторые основные методы Fl_Choice:
Fl_Choice* choice = new Fl_Choice(10, 10, 150, 30, "Choose");
choice->add("Option 1");
choice->add("Option 2");
}
{------------------------------------------Fl_Dial:------------------------------------------------
#include <FL/Fl.H>
#include <FL/Fl_Dial.H>
//Fl_Dial визуально представляет собой круглый элемент управления, который обеспечивает выбор угла вращения (от 0 до 360 градусов).
//Этот угол представляет собой местоположение указателя в пределах круга диала.
Fl_Dial* dial = new Fl_Dial(10, 50, 180, 180, "Dial");
dial->angle1(0); // установка начального угла
dial->angle2(360); // установка конечного угла
}
{------------------------------------------Fl_Box:-------------------------------------------------
#include <FL/Fl.H>
#include <FL/Fl_Box.H>
//Fl_Box в библиотеке FLTK представляет собой виджет, который используется для отображения текста или изображения в рамке.
//Вот некоторые основные методы и свойства класса Fl_Box
Fl_Box* box = new Fl_Box(10, 10, 100, 100, "Box");
box->labeltype(FL_SHADOW_LABEL); // установка стиля метки
}
{------------------------------------------Fl_Text_Display:----------------------------------------
#include <FL/Fl.H>
#include <FL/Fl_Text_Display.H>
//Fl_Text_Display в библиотеке FLTK представляет собой виджет, предназначенный для отображения и редактирования текста.
//Этот виджет обеспечивает множество функций для работы с текстом, включая поддержку форматирования, прокрутку и редактирование.
Fl_Text_Display* textDisplay = new Fl_Text_Display(10, 10, 200, 150, "Text Display");
textDisplay->buffer(new Fl_Text_Buffer()); // установка буф
}
}